%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Rapport Projet}
\author{Paul Patault}
\date{Mars 2022}

\documentclass[twoside,11pt]{article}
\usepackage[code]{ppbase}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}

\vspace*{1.3cm}
\begin{center}
    \textbf{\LARGE Automates et applications} \\
    \bigskip\bigskip
    {\large Paul Patault} \\ % \daggerfootnote{\texttt{paul.patault@universite-paris-saclay.fr}} \\
    \bigskip
    \today
    \bigskip
\end{center}

\begin{abstract}
    Projet du cours Automates et applications. Utilisation de la structure de
    donnée d'automates d'arbres pour vérifier la bonne formation de fichier type
    XML. Ces automates d'arbres seront générés automatiquement à partir d'un fichier
    \textit{à la} DTD donné en entrée du programme. Celui-ci sera donc parsé puis
    compilé dans notre type.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Validation des documents}
Section sans questions.
Simple présentation du sujet, introduction des définitions et du travail attendu.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Validation top-down non-déterministe}
\subsection{Question}

Un run d'un automate d'arbre $A = (Q, \delta, I, F, \Sigma)$
pour un arbre $t \in {\mathcal{T}}(\Sigma)$
est une fonction $r : dom(t) \to Q$
telle que $\forall p \in dom(t), (t(p), r(p), r(p1),r(p2)) \in \delta$.
Un run est dit acceptant si et seulement si $r (\epsilon) \in I$.

\subsection{Question}

\begin{figure}[H]
  \begin{minted}[baselinestretch=1.2,fontsize=\small, escapeinside=\/, mathescape=true]{ocaml}
    let rec validate_td a t p q =
        if label (t p) = '#' then
            true
        else
            let transition = label (t p), q in
            let l = List.filter ((=) transition) a.delta in (* modifier ici *)
            List.fold (fun acc q' ->
                acc ||
                (validate_td a t (p@[first_child (t p)]) q' &&
                 validate_td a t (p@[next_sibling (t p)]) q')
            ) false l
   \end{minted}
\end{figure}

\subsection{Question}

La complexité de l'expression
$\exists$ \ocaml{q} $\in I$ tel que \ocaml{validate_td a t eps q}
est $O(|\ocaml{a}|^{|\ocaml{t}|})$, où $|\ocaml{a}|$ est le nombre de
transitions de l'automate \ocaml{a}. En effet, l'algorithme
nous fait prendre au pire $|\ocaml{a}|$ fois chaque arête de l'arbre \ocaml{t}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Validation bottom-up}

\subsection{Question}
        \bigskip
\begin{figure}[H]
  \begin{minted}[baselinestretch=1.2,fontsize=\small, escapeinside=\/, mathescape=true]{ocaml}
    let rec validate_bu a t p =
        let lab = label (t p) in
        if lab = '#' then
            List.filter ((=) ('#',[],[]) a.trans in
        else
            let left = validate_bu a t (p@[first_child (t p)]) in
            let right = validate_bu a t (p@[next_sibling (t p)]) in
            let res = ref [] in
            List.iter (fun r -> List.iter (fun l ->
                let trans = lab, l, r in
                let possible_states = List.filter ((=) trans) a.trans in
                res <- possible_states :: !res;
            ) left) right
            res
   \end{minted}
\end{figure}


\subsection{Question}

La complexité de l'expression (\ocaml{validate_bu a t eps}) $\cap\ I$ est $O(|\ocaml{t}|)$.


\subsection{Question} TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compilation}
\subsection{Question}
En quelques mots, nous commençons par transformer l'arbre $n$-aire parsé
par la librairie \texttt{Xml-light} en un arbre binaire (le code est situé
dans le fichier \texttt{src/tree.ml}) avec un algorithme simple s'appuyant
sur l'isomorphisme de ces deux structures présenté en fin de cours 3. Ainsi
les fils directs de chaque n\oe{}ud deviennent les fils droits du fils gauche
de ce n\oe{}ud et récursivement.

\begin{figure}[H]
\begin{minted}[baselinestretch=1.2,fontsize=\small, escapeinside=\/, mathescape=true]{ocaml}
        let n2bin input_n_tree =
            let rec aux = function
              | [] -> Leaf
              | node :: sibling -> Node (aux node, aux sibling)
            in
            match input_n_tree with
            | rac, childs -> Node (rac, aux childs, Leaf)
\end{minted}
\end{figure}


\subsection{Question}
L'automate d'arbre produit correspondant au type donné en entrée est de taille ...TODO...


\end{document}
